<!DOCTYPE html><html lang='en'><head><link rel='shortcut icon' href='../media/interface/logo.png' type='image/x-icon'><link rel='icon' href='../media/interface/logo.png' type='image/x-icon'><meta charset='utf-8'><meta name='description' content='Personal Website'><meta name='viewport' content='width=device-width, initial-scale=1.0'><meta name='twitter:card' content='summary'><meta name='twitter:site' content='abstractxan'><meta name='twitter:title' content='abstractxan'><meta name='twitter:description' content='Personal Website'><meta name='twitter:creator' content='@abstractxan '><meta name='twitter:image' content='../media/interface/logo.png'><meta property='og:title' content='abstractxan'><meta property='og:site_name' content='abstractxan'><title> abstractxan - Competitive Coding</title><link rel='stylesheet' type='text/css' href='../links/main.css'><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4MXZVCNV6Q"></script><script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4MXZVCNV6Q'); </script></head><body class='Competitive Coding'><header><a id='logo' href='home.html'><img src='../media/interface/logo.png' alt='AbstractXan' ></a></header><main class='page'><h1>Competitive Coding</h1><ul class='jump'><li><a href='#links'>Links</a></li><li><a href='#questions'>Questions</a></li><li><a href='#curated_questions'>Curated Questions</a></li></ul></ul><h2 id='links'>Links</h2><ul><li> <a href='http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#cplusplus'>Cplusplus Yale Notes</a></li><li> <a href='https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/'>MIT Introduction to Algorithms</a> by Prof. Erik Demaine</li><li> <a href='https://cses.fi/book/book.pdf'>Competitive Programmer's Handbook</a></li><li> <a href='https://leetcode.com/discuss/general-discussion/457546/LeetCode-Problem-Patterns-from-educative.io'>Classification of questions</a></li><li> <a href='https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns'>Dynamic Programming Patterns</a></li><li> <a href='https://atcoder.jp/contests/dp/tasks'>List of DP problems</a> with increasing difficulty   </li><li> <a href='https://en.wikipedia.org/wiki/List_of_data_structures'>List of Data Structures</a></li></ul><h2 id='questions'>Questions</h2> <a href='https://leetcode.com/problems/container-with-most-water/'>Container with most water</a> is a brilliant question with an elegant solution that feels like magic. Initial instinct would be to go through the array in O(n^2) time but turns out that it could be brought down to O(n) time and O(1) space complexity. I wish I could classify this problem but I haven't solved these kinda questions enough.<br> <a href='https://leetcode.com/problems/reveal-cards-in-increasing-order/'>Reveal cards in increasing order</a> is a very good question for testing your knowledge queue implementation.<br></ul><h2 id='curated_questions'>Curated Questions</h2>1.  <a href='https://leetcode.com/problems/uncrossed-lines/'>Uncrossed Lines</a><br><details><summary>Approach 1 : Recursion</summary><pre class="code"><br>int retbest(int a,int b,vector<int> A, vector<int> B){<br>    if(a == A.size() || b==B.size()){<br>        return 0;<br>    }<br>    <br>    int best = 0;<br>    best = max(best,retbest(a+1,b,A,B));<br>    best = max(best,retbest(a,b+1,A,B));<br>    <br>    if (A[a]==B[b]){<br>        best = max(best,retbest(a+1,b+1,A,B)+1);<br>    }<br>    return best;<br>}<br>int maxUncrossedLines(vector<int>& A, vector<int>& B) {<br>    return retbest(0,0,A,B);<br>}<br></pre></details><br><details><summary>Approach 2: Memoization (arrays)</summary><pre class="code"><br>int memo[501][501]; // Storing in memory<br>bool calc[501][501]; // True if calculated<br>int retbest(int a,int b,vector<int> A, vector<int> B){<br>    if(a == A.size() || b==B.size()){<br>        return 0;<br>    }<br><br>    if(calc[a][b]==true){ <br>        return memo[a][b]; // Return calculated <br>    }<br><br>    int best = 0;<br>    best = max(best,retbest(a+1,b,A,B));<br>    best = max(best,retbest(a,b+1,A,B));<br>    <br>    if (A[a]==B[b]){<br>        best = max(best,retbest(a+1,b+1,A,B)+1);<br>    }<br>    <br>    memo[a][b] = best; // Store calculated value<br>    calc[a][b] = true; // Set as calculated<br>    return best;<br>}<br>int maxUncrossedLines(vector<int>& A, vector<int>& B) {<br>    return retbest(0,0,A,B);<br>}<br></pre></details><br><br>2.  <a href=''>Edit Distance</a><br><details><summary>Approach : Memoization (vectors) </summary><br><pre class="code"><br>int minDistance(string word1, string word2) {<br>    int n1 = word1.size();<br>    int n2 = word2.size();<br>    // For memoization.<br>    vector&lt;vector&lt;int&gt;&gt; dp(n1, vector<int>(n2, -1));<br>    int result = cost(word1, word2, n1 - 1, n2 - 1, dp);<br>    return result;<br>}<br>int mini(int a, int b, int c) {<br>    return min(min(a, b), c);    <br>}<br>int cost(string &S, string &T, int i, int j, vector<vector<int>> &dp) {<br>    if (i < 0 || j < 0) {return abs(i - j);} // Insert leftovers<br>    if (dp[i][j] != -1) {return dp[i][j];} // Fetch cache<br>    if (S[i] == T[j]) { // Accept when equal<br>        return dp[i][j] = cost(S, T, i - 1, j - 1, dp); x<br>    }<br>    <br>    return dp[i][j] = mini( 1 + cost(S, T, i - 1, j - 1, dp),   // Replacement<br>                            1 + cost(S, T, i, j - 1, dp),       // Insertion<br>                            1 + cost(S, T, i - 1, j, dp));      // Deletion<br>}<br></pre></details><br><br>Last Updated: 31 May 2020<br><br><hr/></main><footer><p><a href='https://creativecommons.org/licenses/by-nc-sa/4.0/'><img src='../media/interface/cc.svg'></a><a href='https://fosstodon.org/web/accounts/222003'><img src='../media/interface/mastodon.svg'></a><a href='https://twitter.com/AbstractXan'><img src='../media/interface/twitter.svg'></a><a href='https://github.com/AbstractXan'><img src='../media/interface/github.svg'></a><a href="hyper://6599978e4f895acfa32f6d185af863135af01df917945d5f12c0517a50ac1e19/"><img src="../media/interface/beaker.svg"></a><a href="https://webring.xxiivv.com/#random" target='_blank'><img src="https://webring.xxiivv.com/icon.black.svg"/></a><p>Abstractxan Ⓒ 2021 — BY-NC-SA 4.0</p><p></p><form action='https://tinyletter.com/abstractxan' method='post' target='popupwindow' onsubmit='window.open(\'https://tinyletter.com/abstractxan\', \'popupwindow\', \'scrollbars=yes,width=800,height=600\');return true'><input type='email' value='' name='EMAIL' class='email' placeholder='email@address.com' required=''><input type='submit' value='Subscribe' name='subscribe' class='button'></form></p></footer></body></html>